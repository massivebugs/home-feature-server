// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: cashbunny.sql

package queries

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const createAccount = `-- name: CreateAccount :execresult
INSERT INTO
  cashbunny_accounts (
    user_id,
    category,
    name,
    description,
    currency,
    order_index
  )
VALUES
  (
    ?,
    ?,
    ?,
    ?,
    ?,
    COALESCE(
      ?,
      (
        SELECT
          COALESCE(MAX(t.order_index) + 1, 0)
        FROM
          cashbunny_accounts AS t
        WHERE
          t.user_id = ?
      )
    )
  )
`

type CreateAccountParams struct {
	UserID      uint32
	Category    string
	Name        string
	Description string
	Currency    string
	OrderIndex  interface{}
}

func (q *Queries) CreateAccount(ctx context.Context, db DBTX, arg CreateAccountParams) (sql.Result, error) {
	return db.ExecContext(ctx, createAccount,
		arg.UserID,
		arg.Category,
		arg.Name,
		arg.Description,
		arg.Currency,
		arg.OrderIndex,
		arg.UserID,
	)
}

const createRecurrenceRule = `-- name: CreateRecurrenceRule :execresult
INSERT INTO
  cashbunny_recurrence_rules (freq, dtstart, count, ` + "`" + `interval` + "`" + `, ` + "`" + `until` + "`" + `)
VALUES
  (?, ?, ?, ?, ?)
`

type CreateRecurrenceRuleParams struct {
	Freq     string
	Dtstart  time.Time
	Count    int32
	Interval int32
	Until    time.Time
}

func (q *Queries) CreateRecurrenceRule(ctx context.Context, db DBTX, arg CreateRecurrenceRuleParams) (sql.Result, error) {
	return db.ExecContext(ctx, createRecurrenceRule,
		arg.Freq,
		arg.Dtstart,
		arg.Count,
		arg.Interval,
		arg.Until,
	)
}

const createScheduledTransaction = `-- name: CreateScheduledTransaction :execresult
INSERT INTO
  cashbunny_scheduled_transactions (
    user_id,
    category_id,
    src_account_id,
    dest_account_id,
    description,
    amount,
    currency
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?)
`

type CreateScheduledTransactionParams struct {
	UserID        uint32
	CategoryID    sql.NullInt32
	SrcAccountID  uint32
	DestAccountID uint32
	Description   string
	Amount        float64
	Currency      string
}

func (q *Queries) CreateScheduledTransaction(ctx context.Context, db DBTX, arg CreateScheduledTransactionParams) (sql.Result, error) {
	return db.ExecContext(ctx, createScheduledTransaction,
		arg.UserID,
		arg.CategoryID,
		arg.SrcAccountID,
		arg.DestAccountID,
		arg.Description,
		arg.Amount,
		arg.Currency,
	)
}

const createScheduledTransactionRecurrenceRuleRelationship = `-- name: CreateScheduledTransactionRecurrenceRuleRelationship :execresult
INSERT INTO
  cashbunny_scheduled_transactions_recurrence_rules (scheduled_transaction_id, recurrence_rule_id)
VALUES
  (?, ?)
`

type CreateScheduledTransactionRecurrenceRuleRelationshipParams struct {
	ScheduledTransactionID uint32
	RecurrenceRuleID       uint32
}

func (q *Queries) CreateScheduledTransactionRecurrenceRuleRelationship(ctx context.Context, db DBTX, arg CreateScheduledTransactionRecurrenceRuleRelationshipParams) (sql.Result, error) {
	return db.ExecContext(ctx, createScheduledTransactionRecurrenceRuleRelationship, arg.ScheduledTransactionID, arg.RecurrenceRuleID)
}

const createTransaction = `-- name: CreateTransaction :execresult
INSERT INTO
  cashbunny_transactions (
    user_id,
    scheduled_transaction_id,
    category_id,
    src_account_id,
    dest_account_id,
    description,
    amount,
    currency,
    transacted_at
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateTransactionParams struct {
	UserID                 uint32
	ScheduledTransactionID sql.NullInt32
	CategoryID             sql.NullInt32
	SrcAccountID           uint32
	DestAccountID          uint32
	Description            string
	Amount                 float64
	Currency               string
	TransactedAt           time.Time
}

func (q *Queries) CreateTransaction(ctx context.Context, db DBTX, arg CreateTransactionParams) (sql.Result, error) {
	return db.ExecContext(ctx, createTransaction,
		arg.UserID,
		arg.ScheduledTransactionID,
		arg.CategoryID,
		arg.SrcAccountID,
		arg.DestAccountID,
		arg.Description,
		arg.Amount,
		arg.Currency,
		arg.TransactedAt,
	)
}

const createTransactionCategory = `-- name: CreateTransactionCategory :execresult
INSERT INTO
  cashbunny_transaction_categories (
    user_id,
    name
  )
VALUES
  (?, ?)
`

type CreateTransactionCategoryParams struct {
	UserID uint32
	Name   string
}

func (q *Queries) CreateTransactionCategory(ctx context.Context, db DBTX, arg CreateTransactionCategoryParams) (sql.Result, error) {
	return db.ExecContext(ctx, createTransactionCategory, arg.UserID, arg.Name)
}

const createTransactionCategoryAllocation = `-- name: CreateTransactionCategoryAllocation :execresult
INSERT INTO
  cashbunny_transaction_category_allocations (
    user_id,
    category_id,
    amount,
    currency
  )
VALUES
  (?, ?, ?, ?)
`

type CreateTransactionCategoryAllocationParams struct {
	UserID     uint32
	CategoryID uint32
	Amount     float64
	Currency   string
}

func (q *Queries) CreateTransactionCategoryAllocation(ctx context.Context, db DBTX, arg CreateTransactionCategoryAllocationParams) (sql.Result, error) {
	return db.ExecContext(ctx, createTransactionCategoryAllocation,
		arg.UserID,
		arg.CategoryID,
		arg.Amount,
		arg.Currency,
	)
}

const createUserCurrency = `-- name: CreateUserCurrency :execresult
INSERT INTO
  cashbunny_user_currencies (user_id, currency_code)
VALUES
  (?, ?)
`

type CreateUserCurrencyParams struct {
	UserID       uint32
	CurrencyCode string
}

func (q *Queries) CreateUserCurrency(ctx context.Context, db DBTX, arg CreateUserCurrencyParams) (sql.Result, error) {
	return db.ExecContext(ctx, createUserCurrency, arg.UserID, arg.CurrencyCode)
}

const createUserPreferences = `-- name: CreateUserPreferences :execresult
INSERT INTO
  cashbunny_user_preferences (user_id)
VALUES
  (?)
`

func (q *Queries) CreateUserPreferences(ctx context.Context, db DBTX, userID uint32) (sql.Result, error) {
	return db.ExecContext(ctx, createUserPreferences, userID)
}

const deleteAccount = `-- name: DeleteAccount :exec
UPDATE cashbunny_accounts
SET
  deleted_at = CURRENT_TIMESTAMP()
WHERE
  user_id = ?
  AND id = ?
`

type DeleteAccountParams struct {
	UserID uint32
	ID     uint32
}

func (q *Queries) DeleteAccount(ctx context.Context, db DBTX, arg DeleteAccountParams) error {
	_, err := db.ExecContext(ctx, deleteAccount, arg.UserID, arg.ID)
	return err
}

const deleteTransaction = `-- name: DeleteTransaction :exec
UPDATE cashbunny_transactions
SET
  deleted_at = CURRENT_TIMESTAMP()
WHERE
  user_id = ?
  AND id = ?
`

type DeleteTransactionParams struct {
	UserID uint32
	ID     uint32
}

func (q *Queries) DeleteTransaction(ctx context.Context, db DBTX, arg DeleteTransactionParams) error {
	_, err := db.ExecContext(ctx, deleteTransaction, arg.UserID, arg.ID)
	return err
}

const deleteTransactionsByAccountID = `-- name: DeleteTransactionsByAccountID :exec
UPDATE cashbunny_transactions
SET
  deleted_at = CURRENT_TIMESTAMP()
WHERE
  user_id = ?
  AND src_account_id = ?
  OR dest_account_id = ?
`

type DeleteTransactionsByAccountIDParams struct {
	UserID    uint32
	AccountID uint32
}

func (q *Queries) DeleteTransactionsByAccountID(ctx context.Context, db DBTX, arg DeleteTransactionsByAccountIDParams) error {
	_, err := db.ExecContext(ctx, deleteTransactionsByAccountID, arg.UserID, arg.AccountID, arg.AccountID)
	return err
}

const getAccountByID = `-- name: GetAccountByID :one
SELECT
  id, user_id, category, name, description, currency, order_index, created_at, updated_at, deleted_at
FROM
  cashbunny_accounts
WHERE
  user_id = ?
  AND id = ?
  AND deleted_at IS NULL
LIMIT
  1
`

type GetAccountByIDParams struct {
	UserID uint32
	ID     uint32
}

func (q *Queries) GetAccountByID(ctx context.Context, db DBTX, arg GetAccountByIDParams) (*CashbunnyAccount, error) {
	row := db.QueryRowContext(ctx, getAccountByID, arg.UserID, arg.ID)
	var i CashbunnyAccount
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Category,
		&i.Name,
		&i.Description,
		&i.Currency,
		&i.OrderIndex,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getTransactionByID = `-- name: GetTransactionByID :one
SELECT
  id, user_id, scheduled_transaction_id, category_id, src_account_id, dest_account_id, description, amount, currency, transacted_at, created_at, updated_at, deleted_at
FROM
  cashbunny_transactions
WHERE
  user_id = ?
  AND id = ?
  AND deleted_at IS NULL
LIMIT
  1
`

type GetTransactionByIDParams struct {
	UserID uint32
	ID     uint32
}

func (q *Queries) GetTransactionByID(ctx context.Context, db DBTX, arg GetTransactionByIDParams) (*CashbunnyTransaction, error) {
	row := db.QueryRowContext(ctx, getTransactionByID, arg.UserID, arg.ID)
	var i CashbunnyTransaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ScheduledTransactionID,
		&i.CategoryID,
		&i.SrcAccountID,
		&i.DestAccountID,
		&i.Description,
		&i.Amount,
		&i.Currency,
		&i.TransactedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getUserPreferenceByUserID = `-- name: GetUserPreferenceByUserID :one
SELECT
  id, user_id, created_at, updated_at, deleted_at
FROM
  cashbunny_user_preferences
WHERE
  user_id = ?
  AND deleted_at IS NULL
LIMIT
  1
`

func (q *Queries) GetUserPreferenceByUserID(ctx context.Context, db DBTX, userID uint32) (*CashbunnyUserPreference, error) {
	row := db.QueryRowContext(ctx, getUserPreferenceByUserID, userID)
	var i CashbunnyUserPreference
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getUserPreferenceExistsByUserID = `-- name: GetUserPreferenceExistsByUserID :one
SELECT EXISTS (
  SELECT
    id, user_id, created_at, updated_at, deleted_at
  FROM
    cashbunny_user_preferences
  WHERE
    user_id = ?
    AND deleted_at IS NULL
  LIMIT
    1
)
`

func (q *Queries) GetUserPreferenceExistsByUserID(ctx context.Context, db DBTX, userID uint32) (bool, error) {
	row := db.QueryRowContext(ctx, getUserPreferenceExistsByUserID, userID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const incrementAccountIndices = `-- name: IncrementAccountIndices :exec
UPDATE cashbunny_accounts
SET
  order_index = order_index + 1
WHERE
  user_id = ?
  AND order_index >= ?
`

type IncrementAccountIndicesParams struct {
	UserID     uint32
	OrderIndex uint32
}

func (q *Queries) IncrementAccountIndices(ctx context.Context, db DBTX, arg IncrementAccountIndicesParams) error {
	_, err := db.ExecContext(ctx, incrementAccountIndices, arg.UserID, arg.OrderIndex)
	return err
}

const listAccountsAndAmountBetweenDates = `-- name: ListAccountsAndAmountBetweenDates :many
SELECT
  a.id, a.user_id, a.category, a.name, a.description, a.currency, a.order_index, a.created_at, a.updated_at, a.deleted_at,
  CAST(
    COALESCE(
      SUM(
        CASE
          WHEN a.category IN ('assets', 'expenses')
          THEN IF(tr.src_account_id = a.id, -tr.amount, tr.amount)
          ELSE IF(tr.src_account_id = a.id, tr.amount, -tr.amount)
        END
      ), 0
    ) AS DECIMAL(19, 4)
  ) AS amount
FROM
  cashbunny_accounts a
  LEFT JOIN cashbunny_transactions tr
    ON (tr.src_account_id = a.id OR tr.dest_account_id = a.id)
    AND tr.transacted_at BETWEEN ? AND ? 
    AND tr.deleted_at IS NULL
WHERE
  a.user_id = ?
  AND a.deleted_at IS NULL
GROUP BY
  a.id
ORDER BY
  a.order_index
`

type ListAccountsAndAmountBetweenDatesParams struct {
	FromTransactedAt time.Time
	ToTransactedAt   time.Time
	UserID           uint32
}

type ListAccountsAndAmountBetweenDatesRow struct {
	CashbunnyAccount CashbunnyAccount
	Amount           float64
}

func (q *Queries) ListAccountsAndAmountBetweenDates(ctx context.Context, db DBTX, arg ListAccountsAndAmountBetweenDatesParams) ([]*ListAccountsAndAmountBetweenDatesRow, error) {
	rows, err := db.QueryContext(ctx, listAccountsAndAmountBetweenDates, arg.FromTransactedAt, arg.ToTransactedAt, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListAccountsAndAmountBetweenDatesRow{}
	for rows.Next() {
		var i ListAccountsAndAmountBetweenDatesRow
		if err := rows.Scan(
			&i.CashbunnyAccount.ID,
			&i.CashbunnyAccount.UserID,
			&i.CashbunnyAccount.Category,
			&i.CashbunnyAccount.Name,
			&i.CashbunnyAccount.Description,
			&i.CashbunnyAccount.Currency,
			&i.CashbunnyAccount.OrderIndex,
			&i.CashbunnyAccount.CreatedAt,
			&i.CashbunnyAccount.UpdatedAt,
			&i.CashbunnyAccount.DeletedAt,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccountsAndAmountByCategory = `-- name: ListAccountsAndAmountByCategory :many
SELECT
  a.id, a.user_id, a.category, a.name, a.description, a.currency, a.order_index, a.created_at, a.updated_at, a.deleted_at,
  CAST(
    COALESCE(
      SUM(
        CASE
          WHEN a.category IN ('assets', 'expenses')
          THEN IF(tr.src_account_id = a.id, -tr.amount, tr.amount)
          ELSE IF(tr.src_account_id = a.id, tr.amount, -tr.amount)
        END
      ), 0
    ) AS DECIMAL(19, 4)
  ) AS amount
FROM
  cashbunny_accounts a
  LEFT JOIN cashbunny_transactions tr
    ON (tr.src_account_id = a.id OR tr.dest_account_id = a.id)
    AND tr.deleted_at IS NULL
WHERE
  a.user_id = ?
  AND a.category = ?
  AND a.deleted_at IS NULL
GROUP BY
  a.id
ORDER BY
  a.order_index
`

type ListAccountsAndAmountByCategoryParams struct {
	UserID   uint32
	Category string
}

type ListAccountsAndAmountByCategoryRow struct {
	CashbunnyAccount CashbunnyAccount
	Amount           float64
}

func (q *Queries) ListAccountsAndAmountByCategory(ctx context.Context, db DBTX, arg ListAccountsAndAmountByCategoryParams) ([]*ListAccountsAndAmountByCategoryRow, error) {
	rows, err := db.QueryContext(ctx, listAccountsAndAmountByCategory, arg.UserID, arg.Category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListAccountsAndAmountByCategoryRow{}
	for rows.Next() {
		var i ListAccountsAndAmountByCategoryRow
		if err := rows.Scan(
			&i.CashbunnyAccount.ID,
			&i.CashbunnyAccount.UserID,
			&i.CashbunnyAccount.Category,
			&i.CashbunnyAccount.Name,
			&i.CashbunnyAccount.Description,
			&i.CashbunnyAccount.Currency,
			&i.CashbunnyAccount.OrderIndex,
			&i.CashbunnyAccount.CreatedAt,
			&i.CashbunnyAccount.UpdatedAt,
			&i.CashbunnyAccount.DeletedAt,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccountsByIDs = `-- name: ListAccountsByIDs :many
SELECT
  id, user_id, category, name, description, currency, order_index, created_at, updated_at, deleted_at
FROM
  cashbunny_accounts
WHERE
  user_id = ?
  AND deleted_at IS NULL
  AND id IN (/*SLICE:IDs*/?)
ORDER BY
  order_index
`

type ListAccountsByIDsParams struct {
	UserID uint32
	IDs    []uint32
}

func (q *Queries) ListAccountsByIDs(ctx context.Context, db DBTX, arg ListAccountsByIDsParams) ([]*CashbunnyAccount, error) {
	query := listAccountsByIDs
	var queryParams []interface{}
	queryParams = append(queryParams, arg.UserID)
	if len(arg.IDs) > 0 {
		for _, v := range arg.IDs {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:IDs*/?", strings.Repeat(",?", len(arg.IDs))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:IDs*/?", "NULL", 1)
	}
	rows, err := db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CashbunnyAccount{}
	for rows.Next() {
		var i CashbunnyAccount
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Category,
			&i.Name,
			&i.Description,
			&i.Currency,
			&i.OrderIndex,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listScheduledTransactionsWithAllRelations = `-- name: ListScheduledTransactionsWithAllRelations :many
SELECT
  cashbunny_scheduled_transactions.id, cashbunny_scheduled_transactions.user_id, cashbunny_scheduled_transactions.category_id, cashbunny_scheduled_transactions.src_account_id, cashbunny_scheduled_transactions.dest_account_id, cashbunny_scheduled_transactions.description, cashbunny_scheduled_transactions.amount, cashbunny_scheduled_transactions.currency, cashbunny_scheduled_transactions.created_at, cashbunny_scheduled_transactions.updated_at, cashbunny_scheduled_transactions.deleted_at,
  cashbunny_recurrence_rules.id, cashbunny_recurrence_rules.freq, cashbunny_recurrence_rules.dtstart, cashbunny_recurrence_rules.count, cashbunny_recurrence_rules.` + "`" + `interval` + "`" + `, cashbunny_recurrence_rules.until, cashbunny_recurrence_rules.created_at, cashbunny_recurrence_rules.updated_at,
  categories.id, categories.user_id, categories.name, categories.created_at, categories.updated_at, categories.deleted_at,
  source_account.id, source_account.user_id, source_account.category, source_account.name, source_account.description, source_account.currency, source_account.order_index, source_account.created_at, source_account.updated_at, source_account.deleted_at,
  destination_account.id, destination_account.user_id, destination_account.category, destination_account.name, destination_account.description, destination_account.currency, destination_account.order_index, destination_account.created_at, destination_account.updated_at, destination_account.deleted_at
FROM
  cashbunny_scheduled_transactions
  LEFT JOIN cashbunny_scheduled_transactions_recurrence_rules as relationship ON relationship.scheduled_transaction_id = cashbunny_scheduled_transactions.id
  LEFT JOIN cashbunny_recurrence_rules ON cashbunny_recurrence_rules.id = relationship.recurrence_rule_id
  LEFT JOIN cashbunny_transaction_categories AS categories ON categories.id = category_id
  LEFT JOIN cashbunny_accounts AS source_account ON source_account.id = src_account_id
  LEFT JOIN cashbunny_accounts AS destination_account ON destination_account.id = dest_account_id
WHERE
  cashbunny_scheduled_transactions.user_id = ?
  AND cashbunny_scheduled_transactions.deleted_at IS NULL
ORDER BY
  cashbunny_scheduled_transactions.created_at ASC
`

type ListScheduledTransactionsWithAllRelationsRow struct {
	CashbunnyScheduledTransaction CashbunnyScheduledTransaction
	CashbunnyRecurrenceRule       CashbunnyRecurrenceRule
	CashbunnyTransactionCategory  CashbunnyTransactionCategory
	CashbunnyAccount              CashbunnyAccount
	CashbunnyAccount_2            CashbunnyAccount
}

func (q *Queries) ListScheduledTransactionsWithAllRelations(ctx context.Context, db DBTX, userID uint32) ([]*ListScheduledTransactionsWithAllRelationsRow, error) {
	rows, err := db.QueryContext(ctx, listScheduledTransactionsWithAllRelations, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListScheduledTransactionsWithAllRelationsRow{}
	for rows.Next() {
		var i ListScheduledTransactionsWithAllRelationsRow
		if err := rows.Scan(
			&i.CashbunnyScheduledTransaction.ID,
			&i.CashbunnyScheduledTransaction.UserID,
			&i.CashbunnyScheduledTransaction.CategoryID,
			&i.CashbunnyScheduledTransaction.SrcAccountID,
			&i.CashbunnyScheduledTransaction.DestAccountID,
			&i.CashbunnyScheduledTransaction.Description,
			&i.CashbunnyScheduledTransaction.Amount,
			&i.CashbunnyScheduledTransaction.Currency,
			&i.CashbunnyScheduledTransaction.CreatedAt,
			&i.CashbunnyScheduledTransaction.UpdatedAt,
			&i.CashbunnyScheduledTransaction.DeletedAt,
			&i.CashbunnyRecurrenceRule.ID,
			&i.CashbunnyRecurrenceRule.Freq,
			&i.CashbunnyRecurrenceRule.Dtstart,
			&i.CashbunnyRecurrenceRule.Count,
			&i.CashbunnyRecurrenceRule.Interval,
			&i.CashbunnyRecurrenceRule.Until,
			&i.CashbunnyRecurrenceRule.CreatedAt,
			&i.CashbunnyRecurrenceRule.UpdatedAt,
			&i.CashbunnyTransactionCategory.ID,
			&i.CashbunnyTransactionCategory.UserID,
			&i.CashbunnyTransactionCategory.Name,
			&i.CashbunnyTransactionCategory.CreatedAt,
			&i.CashbunnyTransactionCategory.UpdatedAt,
			&i.CashbunnyTransactionCategory.DeletedAt,
			&i.CashbunnyAccount.ID,
			&i.CashbunnyAccount.UserID,
			&i.CashbunnyAccount.Category,
			&i.CashbunnyAccount.Name,
			&i.CashbunnyAccount.Description,
			&i.CashbunnyAccount.Currency,
			&i.CashbunnyAccount.OrderIndex,
			&i.CashbunnyAccount.CreatedAt,
			&i.CashbunnyAccount.UpdatedAt,
			&i.CashbunnyAccount.DeletedAt,
			&i.CashbunnyAccount_2.ID,
			&i.CashbunnyAccount_2.UserID,
			&i.CashbunnyAccount_2.Category,
			&i.CashbunnyAccount_2.Name,
			&i.CashbunnyAccount_2.Description,
			&i.CashbunnyAccount_2.Currency,
			&i.CashbunnyAccount_2.OrderIndex,
			&i.CashbunnyAccount_2.CreatedAt,
			&i.CashbunnyAccount_2.UpdatedAt,
			&i.CashbunnyAccount_2.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionCategories = `-- name: ListTransactionCategories :many
SELECT
  id, user_id, name, created_at, updated_at, deleted_at
FROM
  cashbunny_transaction_categories
WHERE
  user_id = ?
  AND deleted_at IS NULL
ORDER BY
  id ASC
`

func (q *Queries) ListTransactionCategories(ctx context.Context, db DBTX, userID uint32) ([]*CashbunnyTransactionCategory, error) {
	rows, err := db.QueryContext(ctx, listTransactionCategories, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CashbunnyTransactionCategory{}
	for rows.Next() {
		var i CashbunnyTransactionCategory
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionCategoryAllocations = `-- name: ListTransactionCategoryAllocations :many
SELECT
  id, user_id, category_id, amount, currency, created_at, updated_at, deleted_at
FROM
  cashbunny_transaction_category_allocations
WHERE
  user_id = ?
  AND deleted_at IS NULL
`

func (q *Queries) ListTransactionCategoryAllocations(ctx context.Context, db DBTX, userID uint32) ([]*CashbunnyTransactionCategoryAllocation, error) {
	rows, err := db.QueryContext(ctx, listTransactionCategoryAllocations, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CashbunnyTransactionCategoryAllocation{}
	for rows.Next() {
		var i CashbunnyTransactionCategoryAllocation
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.Amount,
			&i.Currency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactions = `-- name: ListTransactions :many
SELECT
  id, user_id, scheduled_transaction_id, category_id, src_account_id, dest_account_id, description, amount, currency, transacted_at, created_at, updated_at, deleted_at
FROM
  cashbunny_transactions
WHERE
  user_id = ?
  AND deleted_at IS NULL
ORDER BY
  transacted_at
`

func (q *Queries) ListTransactions(ctx context.Context, db DBTX, userID uint32) ([]*CashbunnyTransaction, error) {
	rows, err := db.QueryContext(ctx, listTransactions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CashbunnyTransaction{}
	for rows.Next() {
		var i CashbunnyTransaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ScheduledTransactionID,
			&i.CategoryID,
			&i.SrcAccountID,
			&i.DestAccountID,
			&i.Description,
			&i.Amount,
			&i.Currency,
			&i.TransactedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsBetweenDates = `-- name: ListTransactionsBetweenDates :many
SELECT
  id, user_id, scheduled_transaction_id, category_id, src_account_id, dest_account_id, description, amount, currency, transacted_at, created_at, updated_at, deleted_at
FROM
  cashbunny_transactions
WHERE
  user_id = ?
  AND deleted_at IS NULL
  AND transacted_at BETWEEN ? AND ?
ORDER BY
  transacted_at ASC
`

type ListTransactionsBetweenDatesParams struct {
	UserID           uint32
	FromTransactedAt time.Time
	ToTransactedAt   time.Time
}

func (q *Queries) ListTransactionsBetweenDates(ctx context.Context, db DBTX, arg ListTransactionsBetweenDatesParams) ([]*CashbunnyTransaction, error) {
	rows, err := db.QueryContext(ctx, listTransactionsBetweenDates, arg.UserID, arg.FromTransactedAt, arg.ToTransactedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CashbunnyTransaction{}
	for rows.Next() {
		var i CashbunnyTransaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ScheduledTransactionID,
			&i.CategoryID,
			&i.SrcAccountID,
			&i.DestAccountID,
			&i.Description,
			&i.Amount,
			&i.Currency,
			&i.TransactedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserCurrencies = `-- name: ListUserCurrencies :many
SELECT
  id, user_id, currency_code, created_at, updated_at
FROM
  cashbunny_user_currencies
WHERE
  user_id = ?
ORDER BY
  currency_code
`

func (q *Queries) ListUserCurrencies(ctx context.Context, db DBTX, userID uint32) ([]*CashbunnyUserCurrency, error) {
	rows, err := db.QueryContext(ctx, listUserCurrencies, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CashbunnyUserCurrency{}
	for rows.Next() {
		var i CashbunnyUserCurrency
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CurrencyCode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCashbunnyAccount = `-- name: UpdateCashbunnyAccount :exec
UPDATE cashbunny_accounts
SET
  name = ?,
  description = ?,
  order_index = ?
WHERE
  user_id = ?
  AND id = ?
`

type UpdateCashbunnyAccountParams struct {
	Name        string
	Description string
	OrderIndex  uint32
	UserID      uint32
	ID          uint32
}

func (q *Queries) UpdateCashbunnyAccount(ctx context.Context, db DBTX, arg UpdateCashbunnyAccountParams) error {
	_, err := db.ExecContext(ctx, updateCashbunnyAccount,
		arg.Name,
		arg.Description,
		arg.OrderIndex,
		arg.UserID,
		arg.ID,
	)
	return err
}

const updateCashbunnyTransaction = `-- name: UpdateCashbunnyTransaction :exec
UPDATE cashbunny_transactions
SET
  description = ?,
  amount = ?,
  transacted_at = ?
WHERE
  user_id = ?
  AND id = ?
`

type UpdateCashbunnyTransactionParams struct {
	Description  string
	Amount       float64
	TransactedAt time.Time
	UserID       uint32
	ID           uint32
}

func (q *Queries) UpdateCashbunnyTransaction(ctx context.Context, db DBTX, arg UpdateCashbunnyTransactionParams) error {
	_, err := db.ExecContext(ctx, updateCashbunnyTransaction,
		arg.Description,
		arg.Amount,
		arg.TransactedAt,
		arg.UserID,
		arg.ID,
	)
	return err
}
