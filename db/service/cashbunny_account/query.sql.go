// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package cashbunny_account

import (
	"context"
	"database/sql"
)

const createAccount = `-- name: CreateAccount :execresult
INSERT INTO
  cashbunny_accounts (
    user_id,
    category_id,
    name,
    description,
    balance,
    currency,
    type,
    order_index
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateAccountParams struct {
	UserID      uint32
	CategoryID  uint32
	Name        string
	Description string
	Balance     float64
	Currency    string
	Type        string
	OrderIndex  uint32
}

func (q *Queries) CreateAccount(ctx context.Context, db DBTX, arg CreateAccountParams) (sql.Result, error) {
	return db.ExecContext(ctx, createAccount,
		arg.UserID,
		arg.CategoryID,
		arg.Name,
		arg.Description,
		arg.Balance,
		arg.Currency,
		arg.Type,
		arg.OrderIndex,
	)
}

const createAccountCategory = `-- name: CreateAccountCategory :execresult
INSERT INTO
  cashbunny_account_categories (user_id, name, description)
VALUES
  (?, ?, ?)
`

type CreateAccountCategoryParams struct {
	UserID      uint32
	Name        string
	Description string
}

func (q *Queries) CreateAccountCategory(ctx context.Context, db DBTX, arg CreateAccountCategoryParams) (sql.Result, error) {
	return db.ExecContext(ctx, createAccountCategory, arg.UserID, arg.Name, arg.Description)
}

const deleteAccount = `-- name: DeleteAccount :exec
UPDATE cashbunny_accounts
SET
  deleted_at = CURRENT_TIMESTAMP()
WHERE
  user_id = ?
  AND id = ?
`

type DeleteAccountParams struct {
	UserID uint32
	ID     uint32
}

func (q *Queries) DeleteAccount(ctx context.Context, db DBTX, arg DeleteAccountParams) error {
	_, err := db.ExecContext(ctx, deleteAccount, arg.UserID, arg.ID)
	return err
}

const getAccountCategoryByID = `-- name: GetAccountCategoryByID :one
SELECT
  id, user_id, name, description, created_at, updated_at, deleted_at
FROM
  cashbunny_account_categories
WHERE
  user_id = ?
  AND deleted_at IS NULL
  AND id = ?
LIMIT
  1
`

type GetAccountCategoryByIDParams struct {
	UserID uint32
	ID     uint32
}

func (q *Queries) GetAccountCategoryByID(ctx context.Context, db DBTX, arg GetAccountCategoryByIDParams) (*CashbunnyAccountCategory, error) {
	row := db.QueryRowContext(ctx, getAccountCategoryByID, arg.UserID, arg.ID)
	var i CashbunnyAccountCategory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getAccountCategoryByName = `-- name: GetAccountCategoryByName :one
SELECT
  id, user_id, name, description, created_at, updated_at, deleted_at
FROM
  cashbunny_account_categories
WHERE
  user_id = ?
  AND deleted_at IS NULL
  AND name = ?
LIMIT
  1
`

type GetAccountCategoryByNameParams struct {
	UserID uint32
	Name   string
}

func (q *Queries) GetAccountCategoryByName(ctx context.Context, db DBTX, arg GetAccountCategoryByNameParams) (*CashbunnyAccountCategory, error) {
	row := db.QueryRowContext(ctx, getAccountCategoryByName, arg.UserID, arg.Name)
	var i CashbunnyAccountCategory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const incrementIndex = `-- name: IncrementIndex :exec
UPDATE cashbunny_accounts
SET
  order_index = order_index + 1
WHERE
  user_id = ?
  AND order_index >= ?
`

type IncrementIndexParams struct {
	UserID     uint32
	OrderIndex uint32
}

func (q *Queries) IncrementIndex(ctx context.Context, db DBTX, arg IncrementIndexParams) error {
	_, err := db.ExecContext(ctx, incrementIndex, arg.UserID, arg.OrderIndex)
	return err
}

const listAccountCategoriesByUserID = `-- name: ListAccountCategoriesByUserID :many
SELECT
  id, user_id, name, description, created_at, updated_at, deleted_at
FROM
  cashbunny_account_categories
WHERE
  user_id = ?
  AND deleted_at IS NULL
`

func (q *Queries) ListAccountCategoriesByUserID(ctx context.Context, db DBTX, userID uint32) ([]*CashbunnyAccountCategory, error) {
	rows, err := db.QueryContext(ctx, listAccountCategoriesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CashbunnyAccountCategory{}
	for rows.Next() {
		var i CashbunnyAccountCategory
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccounts = `-- name: ListAccounts :many
SELECT
  id, user_id, category_id, name, description, balance, currency, type, order_index, created_at, updated_at, deleted_at
FROM
  cashbunny_accounts
WHERE
  user_id = ?
  AND deleted_at IS NULL
ORDER BY
  order_index
`

func (q *Queries) ListAccounts(ctx context.Context, db DBTX, userID uint32) ([]*CashbunnyAccount, error) {
	rows, err := db.QueryContext(ctx, listAccounts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CashbunnyAccount{}
	for rows.Next() {
		var i CashbunnyAccount
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.Name,
			&i.Description,
			&i.Balance,
			&i.Currency,
			&i.Type,
			&i.OrderIndex,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccountsAndCategories = `-- name: ListAccountsAndCategories :many
SELECT
  cashbunny_accounts.id, cashbunny_accounts.user_id, cashbunny_accounts.category_id, cashbunny_accounts.name, cashbunny_accounts.description, cashbunny_accounts.balance, cashbunny_accounts.currency, cashbunny_accounts.type, cashbunny_accounts.order_index, cashbunny_accounts.created_at, cashbunny_accounts.updated_at, cashbunny_accounts.deleted_at,
  cashbunny_account_categories.id, cashbunny_account_categories.user_id, cashbunny_account_categories.name, cashbunny_account_categories.description, cashbunny_account_categories.created_at, cashbunny_account_categories.updated_at, cashbunny_account_categories.deleted_at
FROM
  cashbunny_accounts
  LEFT JOIN cashbunny_account_categories ON cashbunny_account_categories.id = cashbunny_accounts.category_id
WHERE
  cashbunny_accounts.user_id = ?
  AND cashbunny_accounts.deleted_at IS NULL
ORDER BY
  cashbunny_accounts.order_index
`

type ListAccountsAndCategoriesRow struct {
	CashbunnyAccount         CashbunnyAccount
	CashbunnyAccountCategory CashbunnyAccountCategory
}

func (q *Queries) ListAccountsAndCategories(ctx context.Context, db DBTX, userID uint32) ([]*ListAccountsAndCategoriesRow, error) {
	rows, err := db.QueryContext(ctx, listAccountsAndCategories, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListAccountsAndCategoriesRow{}
	for rows.Next() {
		var i ListAccountsAndCategoriesRow
		if err := rows.Scan(
			&i.CashbunnyAccount.ID,
			&i.CashbunnyAccount.UserID,
			&i.CashbunnyAccount.CategoryID,
			&i.CashbunnyAccount.Name,
			&i.CashbunnyAccount.Description,
			&i.CashbunnyAccount.Balance,
			&i.CashbunnyAccount.Currency,
			&i.CashbunnyAccount.Type,
			&i.CashbunnyAccount.OrderIndex,
			&i.CashbunnyAccount.CreatedAt,
			&i.CashbunnyAccount.UpdatedAt,
			&i.CashbunnyAccount.DeletedAt,
			&i.CashbunnyAccountCategory.ID,
			&i.CashbunnyAccountCategory.UserID,
			&i.CashbunnyAccountCategory.Name,
			&i.CashbunnyAccountCategory.Description,
			&i.CashbunnyAccountCategory.CreatedAt,
			&i.CashbunnyAccountCategory.UpdatedAt,
			&i.CashbunnyAccountCategory.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
